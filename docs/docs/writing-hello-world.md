# Writing the sample enclave

## Prerequisites
This tutorial assumes that you have completed the [Running your first enclave](running-hello-world.md) tutorial.

## Introduction

In this tutorial, we will cover the following:

* Setting up a new Conclave project using [Conclave Init](conclave-init.md).
* Modifying the files to create an implementation of the Conclave *sample app* which we explored in the
  [previous tutorial](running-hello-world.md).

We will be leveraging Conclave's built-in web host to write our Conclave app. To learn more about this, see
[Conclave web host](conclave-web-host.md). You may want to implement your own host if you need custom functionality or
you want to incorporate it into an existing server application of some kind. To learn more about that, see
[Writing your own enclave host](writing-your-own-enclave-host.md).

The client will be a command line app. This is just for simplicity, and you are free to implement
your client as a GUI app or integrate it with some other program.

## Project Setup
Start by creating a new Conclave project using [Conclave Init](conclave-init.md).
```bash
java -jar <path to sdk>/tools/conclave-init.jar \
    --package com.example.tutorial \
    --enclave-class-name ReverseEnclave \
    --target <your project directory>

cd <your project directory>
```

!!! note
    * Conclave Init will create the project directory for you, so there's no need to create it beforehand.
    * See the [Conclave Init](conclave-init.md#appendix-description-of-generated-files) reference page for a description
    of the files generated by Conclave Init.

## Configure Signing Keys

Modify the `enclave/build.gradle` to specify the signing methods for each of the build types. You could keep your
private key in a file for both debug and release enclaves if you like, but some organisations require private keys to
be held in an offline system or HSM. In that case, configure it like this:

```groovy hl_lines="5-27"
conclave {
    productID = 1
    revocationLevel = 0

    // For simulation, we want to use the default signing type of dummyKey so
    // we do not need to specify a configuration.

    debug {
        signingType = privateKey
        signingKey = file("../signing/sample_private_key.pem")
    }

    release {
        // To protect our release private key with an HSM, the enclave needs to be built in stages.
        // Firstly, build the signing material:
        //  ./gradlew prepareForSigning -PenclaveMode="Release"
        //
        // Generate a signature from the signing material.
        //
        // Finally build the signed enclave:
        //  ./gradlew :host:bootJar -PenclaveMode="Release"
        //
        signingType = externalKey
        signatureDate = new Date(1970, 0, 1)
        mrsignerSignature = file("../signing/signature.bin")
        mrsignerPublicKey = file("../signing/external_signing_public.pem")
    }
}
```

The example configuration above specifies different [signing configurations](signing.md#signing-configurations) for
each of the different build types.

* Simulation builds use the default dummy key.
* Debug builds use a private key stored in a file.
* Release builds use a private key managed by some external signing process.

The `hello world` [sample](https://github.com/R3Conclave/conclave-tutorials/tree/HEAD/hello-world) repository contains some example
keys that can be used with the `privateKey` and `externalKey` signing types. These can be found in `signing` directory.

| Key Files              | Description                                                                                                                                                                  |
|:-----------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| sample_private_key.pem | A 3072 bit RSA private key that can be used to test the ```privateKey``` signing type                                                                                        |
| external_signing_*.pem | An AES encrypted 3072 bit RSA public/private key pair that can be used to test the ```externalKey``` signing type. The private key can be accessed with the password '12345' |

Copy the `signing` directory from the SDK into your project and/or update the paths in the enclave `build.gradle`.
Alternatively you can provide or [generate your own](signing.md#generating-keys-for-signing-an-enclave) keys.

!!! important
    These keys aren't whitelisted by Intel so you can't use them for real release builds.
    Only use these sample keys for the tutorial. Don't use them for signing your own enclaves!


## Create a new subclass of [`Enclave`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/index.html)

Enclaves are similar to standalone programs and as such have an equivalent to a "main class". This class must be a
subclass of [`Enclave`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/index.html).

Replace the contents of `/enclave/src/.../ReverseEnclave.java` with the following:

```java
package com.example.tutorial.enclave;

import com.r3.conclave.enclave.Enclave;

/**
 * Simply reverses the bytes that are passed in.
 */
public class ReverseEnclave extends Enclave {

    private String reverse(String input) {
        var builder = new StringBuilder(input.length());
        for (var i = input.length() - 1; i >= 0; i--) {
            builder.append(input.charAt(i));
        }
        return builder.toString();
    }

    @Override
    protected void receiveMail(EnclaveMail mail, String routingHint) {
        // First, decode mail body as a String.
        var stringToReverse = new String(mail.getBodyAsBytes());
        // Reverse it and re-encode to UTF-8 to send back.
        var reversedEncodedString = reverse(stringToReverse).getBytes();
        // Get the post office object for responding back to this mail and use it to encrypt our response.
        var responseBytes = postOffice(mail).encryptMail(reversedEncodedString);
        postMail(responseBytes, routingHint);
    }
}
```

### Enclave code breakdown

!!! note
    You'll notice that the enclave code is using the `var` syntax that was introduced in Java 10. The
    enclave environment supports up to Java 17!

!!! note
    Since we have replaced the enclave code, the enclave unit tests generated by conclave-init will fail. You may want
    to delete the file `ReverseEnclaveTest.java` or comment out the test code. This will be revisited later in this
    tutorial.

#### Enclave functionality (`reverse` method)

The first method in our enclave is the `reverse` function, which iteratively reverses a string. This serves as the
functionality that we will provide to the client. In general though, your enclave should implement any logic that has to
operate on secure data.

#### Enclave communication (`receiveMail` override)

The second method in our enclave implementation is an override of the
[`receiveMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/receive-mail.html) method. This is the means by which
messages enter the enclave.

This method is called by the host when messages are sent to the enclave and makes use of the
[Conclave mail](architecture.md#mail) API to facilitate encryption and authentication of messages. In the case of the
enclave in this tutorial, it is also where replies are sent back to the host using the
[`postMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/post-mail.html) method. The host then delivers the
encrypted reply back to the appropriate client. In this tutorial, we will be handling transport using the built in
[conclave web host](conclave-web-host.md), which allows clients to deliver and receive mail items via a simple REST API.
In practice however, any method of transport can be used (see [writing your own host](writing-your-own-enclave-host.md)
for an example using plain TCP sockets).

In the case of this enclave, the [`receiveMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/receive-mail.html)
method proceeds as follows:

1. Extract the body bytes from the mail object and interpret them as a string.
1. Reverse the string using the `reverse` method.
1. Create a mail object encrypted to the sender of the received mail object, containing the reversed string.
1. Use [`postMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/post-mail.html) to send the mail item containing the
   reversed result back to the client.

!!! tip
    [`postMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/post-mail.html) can be called at any time within the enclave,
    including from within [`receiveFromUntrustedHost`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/receive-from-untrusted-host.html).
    It can be addressed to any client (using the routing hint) and it need not necessarily be called only in response to a message
    from the sender. You can also post multiple mail objects at once by calling [`postMail`](api/-conclave%20-core/com.r3.conclave.enclave/-enclave/post-mail.html)
    multiple times.

The routing hint parameter is provided by the host and is used to route replies back to the appropriate client when
communicating with multiple clients simultaneously. For more information about this and about other components of the
mail API, see the page on [Conclave mail](architecture.md#mail).

!!! tip
    In a real app you would use the byte array to hold serialised data structures. You can use whatever data formats you
    like. You could use a simple string format or a binary format like protocol buffers.

!!! note
    Enclaves support multi-threaded handling of mail, however this functionality must be explicitly enabled. See the page on
    [enclave threading](threads.md) to learn more.

## Remote attestation

Before we continue onto the client, we first need to quickly talk about remote attestation and why it's important.

There's no point in using an enclave to protect purely local data, as the data must ultimately come from the
(assumed malicious/compromised) host in that scenario. That's why you need remote attestation, which lets an enclave
prove its identity to the third parties who will upload secret data. If this paragraph doesn't make
sense please review the [Architecture overview](architecture.md) and the [Enclaves](enclaves.md) section.

Before a client can set up communication with an enclave it must first get its remote attestation object, or its
[`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html). How a client gets
hold of enclave's `EnclaveInstanceInfo` depends on the host. It could be a REST endpoint, which is what we'll be
using, or as a file downloaded out of band.

The [`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html) has a useful
`toString` function that will print out something like this:

```text
Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F:
  - Mode: SIMULATION
  - Code signer: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B
  - Session signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542
  - Session encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973
  - Product ID: 1
  - Revocation level: 0

Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE
  - Enclave is running in simulation mode.
```

The hash in the first line is the *measurement*. This is a hash of the code of the enclave. It includes both all
the Java code inside the enclave as a fat-JAR, and all the support and JVM runtime code required. As such it will
change any time you alter the code of your enclave, the version of Conclave in use or the mode
(simulation/debug/release) of the enclave. The enclave measurement should be stable across builds and machines, so
clients can audit the enclave by repeating the Gradle build and comparing the value they get in the
[`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html) against what the build process prints out.

!!! tip
    1. All this data is available via individual getters on the
       [`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html) so you should
       never feel a need to parse the output of `toString`.
    2. `EnclaveInstanceInfo` is an interface so you can easily build mock attestations in your tests.
    3. When not in simulation mode the timestamp is signed by Intel and comes from their servers.

An instance has a [security assessment](api/-conclave%20-core/com.r3.conclave.common/-enclave-security-info/index.html), which can
change in response to discovery of vulnerabilities in the
infrastructure (i.e. without anything changing about the host or enclave itself). As we can see this enclave isn't
actually considered secure yet because we're running in simulation mode still. An enclave can be `SECURE`, `STALE`,
or `INSECURE`. An assessment of `STALE` means there is a software/firmware/microcode update available for the platform
that improves security in some way. The client may wish to observe when this starts being reported and define a
time span in which the remote enclave operator must upgrade.

An attestation doesn't inherently expire but because the SGX ecosystem is always moving, client code will typically have
some frequency with which it expects the host code to refresh the
[`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html). At present this is
done by stopping/closing and then restarting the enclave.

## Run the host and enclave

We should be ready to run the host web server from the command line. This is the same as when we ran the host
in [Running your first enclave](running-hello-world.md).

```bash
./gradlew host:bootJar
java -jar host/build/libs/host-mock.jar
```

## Write the client

The client app will do three things:

1. Connect to the host web server and download the [`EnclaveInstanceInfo`](api/-conclave%20-core/com.r3.conclave.common/-enclave-instance-info/index.html) from it.
1. Verify the enclave is acceptable: i.e. that it will do what's expected.
1. Send it the command line arguments as a string to reverse and get back the answer, using encrypted mail.

Actually, the first two steps are done for you when using an
[`EnclaveClient`](api/-conclave%20-core/com.r3.conclave.client/-enclave-client/index.html) object. `EnclaveClient` handles the encryption and
decryption of Mail for you and provides a simple interface for sending and receiving Mail. However, it doesn't know
_how_ to transport the mail, which is where [`EnclaveTransport`](api/-conclave%20-core/com.r3.conclave.client/-enclave-transport/index.html)
comes in. Since we're connecting to the host web server, we'll be using
[`WebEnclaveTransport`](api/-conclave%20-core/com.r3.conclave.client.web/-web-enclave-transport/index.html) as our transport.

Replace the client code at `client/src/.../ReverseEnclaveClient.java`

```java
package com.example.tutorial.client;

import com.r3.conclave.client.EnclaveClient;
import com.r3.conclave.client.web.WebEnclaveTransport;
import com.r3.conclave.common.EnclaveConstraint;
import com.r3.conclave.common.InvalidEnclaveException;
import com.r3.conclave.mail.EnclaveMail;

import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class ReverseEnclaveClient {
    private static String DESCRIPTION = "Simple client that communicates with the ReverseEnclave using the web host.";
    private static String USAGE_MESSAGE = "Usage: reverse-client ENCLAVE_CONSTRAINT STRING_TO_REVERSE\n" +
            "  ENCLAVE_CONSTRAINT: Enclave constraint which determines the enclave's identity and whether it's " +
            "acceptable to use.\n" +
            "  STRING_TO_REVERSE: The string to send to the enclave to reverse.";

    private static String REVERSE_HOST_URL = "http://localhost:8080";

    public static void main(String... args) throws IOException, InvalidEnclaveException {
        if (args.length != 2) {
            System.out.println(DESCRIPTION);
            System.out.println(USAGE_MESSAGE);
        }

        EnclaveConstraint constraint = EnclaveConstraint.parse(args[0]);
        String stringToReverse = args[1];

        callEnclave(constraint, stringToReverse);
    }

    public static void callEnclave(EnclaveConstraint constraint, String stringToReverse) throws IOException, InvalidEnclaveException {
        try (WebEnclaveTransport transport = new WebEnclaveTransport(REVERSE_HOST_URL);
             EnclaveClient client = new EnclaveClient(constraint)) {

            client.start(transport);
            // TODO
        }
    }
}
```

The `constraint`, provided to the
[`EnclaveClient` constructor](api/-conclave%20-core/com.r3.conclave.client/-enclave-client/-enclave-client.html) is the same
constraint that we supplied when running the client
in [Running your first enclave](running-hello-world.md#run-the-client)

The client wants to receive a response from the enclave, and we want that to be encrypted/tamperproofed too. That means it
needs a key pair of its own.

The complexity of dealing with private keys is conveniently hidden inside `EnclaveClient`. The
`new EnclaveClient(constraint)` line in the above code also creates a new random Curve25519 private key. If you
have an existing private key that you want to use, or want to manually create a new random key, then you could do
something like:

```java
PrivateKey myKey = Curve25519PrivateKey.random();
EnclaveClient client = new EnclaveClient(myKey, constraint);
```

!!! note
    Unfortunately the Java Cryptography Architecture only introduced official support for Curve25519 in Java 11. Since
    Conclave supports Java 8, you must utilize our
    [`Curve25519PublicKey`](api/-conclave%20-core/com.r3.conclave.mail/-curve25519-public-key/index.html) and
    [`Curve25519PrivateKey`](api/-conclave%20-core/com.r3.conclave.mail/-curve25519-private-key/index.html) classes. 
    A Curve25519 private key is simply 32 random bytes, which you can access by calling `getEncoded()` on `PrivateKey`.

### Sending and receiving mail

Now that we've connected to the host web server and verified we're communicating with the right enclave we can now
send it mail. This is done by calling
[`EnclaveClient.sendMail`](api/-conclave%20-core/com.r3.conclave.client/-enclave-client/send-mail.html) and passing in the
serialized bytes of the request
message. If the enclave responds back immediately with a mail of its own then that is returned by `sendMail`. We can
use all of this to fill in the missing piece in our client:

```java hl_lines="5 7-12"
public static void callEnclave(EnclaveConstraint constraint, String stringToReverse) throws IOException, InvalidEnclaveException {
    try (WebEnclaveTransport transport = new WebEnclaveTransport(REVERSE_HOST_URL);
         EnclaveClient client = new EnclaveClient(constraint)) {

        // Connect to the host and send the string to reverse
        client.start(transport);
        byte[] requestMailBody = stringToReverse.getBytes(StandardCharsets.UTF_8);
        EnclaveMail responseMail = client.sendMail(requestMailBody);

        // Parse and print out the response
        String responseString = (responseMail != null) ? new String(responseMail.getBodyAsBytes()) : null;
        System.out.println("Reversing `" + stringToReverse + "` gives `" + responseString + "`");
    }
}
```

The response we get back from the enclave is represented as an
[`EnclaveMail`](api/-conclave%20-core/com.r3.conclave.mail/-enclave-mail/index.html) object. We need the mail body which
contains the encoded reversed string.

!!! tip
    If you write your enclave such that it might respond back to the client later at some point then you can use the
    [`pollMail`](api/-conclave%20-core/com.r3.conclave.client/-enclave-client/poll-mail.html) method to poll for responses.
    It will return `null` if there aren't any.

## Run the client

Our application is complete. Run the host with
```bash
java -jar host/build/libs/host-mock.jar
```

In a separate terminal, build and run the client:
```bash
./gradlew :client:shadowJar

java -jar client/build/libs/client.jar \
  "S:0000000000000000000000000000000000000000000000000000000000000000 PROD:1 SEC:INSECURE" \
  reverse-me
```

Please refer to [Running your first enclave](running-hello-world.md) for expected output and other information on these
commands.

## Testing

There are two ways you can test the enclave: using a mock build of the enclave in tests defined as part of
your enclave project, or integrating enclave tests in your host project.

### Mock tests within the enclave project

Mock mode allows you to whitebox test your enclave by running it fully in-memory. There is no need for SGX hardware
or a specific OS and thus it is ideal for cross-platform unit testing.

Conclave supports building and running tests within the enclave project itself. When you define tests as part
of your enclave project, the enclave classes are loaded along with the tests. Conclave detects this
configuration and automatically enables mock mode for the enclave and test host. You do not need to explicitly
specify [mock mode](mockmode.md) for your project.

To use this functionality, simply create an instance of the enclave as usual by calling
[`EnclaveHost.load`](api/-conclave%20-core/com.r3.conclave.host/-enclave-host/load.html) inside your test class.

```java
EnclaveHost mockHost = EnclaveHost.load("com.r3.conclave.sample.enclave.ReverseEnclave");
mockHost.start(null, null);
```

Conclave will detect that the enclave class is on the classpath and will start the enclave in mock mode. You
can obtain the enclave instance using the
[`EnclaveHost.mockEnclave`](api/-conclave%20-core/com.r3.conclave.host/-enclave-host/get-mock-enclave.html) property.

```java
ReverseEnclave reverseEnclave = (ReverseEnclave)mockHost.getMockEnclave();
```

### Integrating enclave tests in your host project

When you want to test your enclave on real SGX hardware or in a simulated SGX environment **you need to define your tests
in a project separate from the enclave project.** A suitable place for your tests would be to define them as part of
the host project tests.

Add the Conclave host as a `testImplementation` dependency in the project where your tests will be defined.

```groovy
dependencies {
    testImplementation "com.r3.conclave:conclave-host:$conclaveVersion"
}
```

Loading and testing the enclave on real hardware or in a simulated SGX environment is straightforward: the enclave needs
to be loaded with [`EnclaveHost.load`](api/-conclave%20-core/com.r3.conclave.host/-enclave-host/load.html). By default, this
will run the tests in a simulated SGX environment and will require
the tests to be executed within Linux. In addition, testing on real hardware will require the tests to be executed within
Linux on a system that supports SGX.

```java
@EnabledOnOs(OS.LINUX)
public class NativeTest {
    private static EnclaveHost enclave;

    @BeforeAll
    static void startup() throws EnclaveLoadException {
        enclave = EnclaveHost.load("com.r3.conclave.sample.enclave.ReverseEnclave");
        enclave.start(new AttestationParameters.DCAP(), null, null);
    }
}
```

You'll notice that we annotated the test class with `@EnabledOnOs(OS.LINUX)`. This is from
[JUnit 5](https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-os) and it will make sure
the native test isn't run on non-Linux environments.

The tests can use any enclave mode: release, debug, simulation or mock. Therefore, if you want to run your tests on
a non-Linux system then you can configure your tests to depend on a mock mode enclave instead. In this case, remove the
`@EnabledOnOs(OS.LINUX)` annotation from the above code.

!!! note
    Running your integration tests in mock mode is very similar to
    [Integrating enclave tests in your host project](#integrating-enclave-tests-in-your-host-project). In both cases
    the enclave code is loaded and run fully in memory. However, for integration tests, you can also choose to run
    the tests in modes other than mock, which is not possible for enclave project tests.

Running

```
./gradlew host:test
```

will execute the test using a simulation enclave, or not at all if the OS is not Linux. You can switch to a debug enclave
and test on real secure hardware by using the `-PenclaveMode` flag:

```
./gradlew -PenclaveMode=debug host:test
```

Or you can use a mock enclave and test on a non-Linux platform by removing `@EnabledOnOs(OS.LINUX)` and by running this
command:

```
./gradlew -PenclaveMode=mock host:test
```

!!! tip
    To run the tests in a simulated SGX environment on a non-Linux machine you can use Docker, which manages Linux
    VMs for you. See the [system requirements](enclave-modes.md#system-requirements) and instructions
    for [compiling and running the host](running-hello-world.md#beyond-mock-mode) for more
    information.
