# Configuring Conclave for use with the KDS
This page covers how to configure your enclave project to use KDS keys.
More detailed information about the architecture of the KDS can be found [here](kds-detail.md).

## What is the KDS?
By default, Conclave persists encrypted data outside the enclave using keys which are specific to the CPU which the enclave is running on.
This causes problems for cloud applications where virtual machines may be re-provisioned and moved to different hardware.

In addition to CPU based keys for storage, Conclave makes use of random session keys for communication.
This presents additional problems for cloud applications which involve horizontal scaling, because the session key will be different for each enclave in the cluster.

The Conclave Key Derivation Service (KDS) is an enclave based service which solves these problems by providing Conclave enclaves a means to securely derive stable keys for both storage and communication.
R3 provides a publicly accessible instance of the KDS as part of the Conclave Platform which may be used by any Conclave based enclave.

!!!Note
    The URL for the R3 public KDS is `https://kds.dev.conclave.cloud`.
    This is URL may be changed in a later deployment of the KDS.

## Configuring the KDS URL
For an enclave to obtain keys from a KDS, the URL of a KDS instance must be provided when the enclave is started.

!!!Note
    If the KDS URL is not provided and the enclave is a simulation or debug mode enclave, a warning will be printed and the enclave will default to signer derived keys.
    This behaviour allows for enclave development without a connection to a KDS.
    If a release mode enclave is started without the KDS URL, an error will be generated and the enclave will not start.

### Web host configuration
If you are using the [Conclave web host](conclave-web-host.md), the KDS url and timeout duration in seconds can be provided on the command line when starting your application:

```
--kds.url=https://kds.dev.conclave.cloud
--kds.connection.timeout.seconds=60
```

### Custom host configuration
If you are writing a custom host for your enclave, or you're instantiating the enclave as part of an existing project, you can configure the KDS URL by providing a [`KDSConfiguration`](api/-conclave/com.r3.conclave.host.kds/-k-d-s-configuration/index.html) object when starting the enclave (see [`EnclaveHost.start`](api/-conclave/com.r3.conclave.host/-enclave-host/start.html)):

```java
import com.r3.conclave.host.kds.KDSConfiguration;

...

KDSConfiguration kdsConfiguration = new KDSConfiguration("https://kds.dev.conclave.cloud");
EnclaveHost enclaveHost = EnclaveHost.load("com.example.MyEnclave");
enclaveHost.start(null, null, null, kdsConfiguration) {}

```

## KDS keys for persistent storage
To use KDS derived keys for persistent storage, a specification for how storage keys will be derived must also be provided.
Key specifications are configured on a per-enclave basis and are included in the enclave build configuration.

The format of the KDS configuration is as follows:

```groovy
conclave {
  ...
  kds {
    kdsEnclaveConstraint = "<KDS enclave policy constraints>"
    persistencekeySpec {
      masterKeyType = ("development"|"cluster"|"akv_hsm")
      policyConstraint {
        constraint = "<key policy constraints>"
        useOwnCodeHash = (true|false)                 // Optional
        useOwnCodeSignerAndProductID = (true|false)   // Optional
      }
    }
  }
  ...
}
```

#### KDS block
The `kds {}` section contains all KDS related configuration:

- `kdsEnclaveConstraint` - The constraints that the KDS enclave must match.
- `persististenceKeySpec` - Subsection containing specifications for how encrypted storage keys should be derived.

#### Persistence key specification section (`persistenceKeySpec`)
- `masterKeyType` - Which master KDS master key should we use when deriving a key, supported values are `development`, `cluster` and `azure_hsm`.
- `policyConstraint` - Subsection which contains configuration for the constraints that an enclave must meet in order to access a key generated by the KDS.

#### Policy constraint section (`policyConstraint`)
- `constraint` - The policy constraint that the enclave should meet in order to be allowed to derive the key, this has the same format as the [enclave constraints](constraints.md) DSL which Conclave uses for attestation.
- `useOwnCodeHash` - Use the code hash of this enclave. This will add the code hash of the enclave to the `constraint` property at runtime.
- `useOwnCodeSignerAndProductID` - Use the code signer and product ID of this enclave. This will add the code signer and product ID of the enclave to the `constraint` property at runtime.

### Choosing a value for the `kdsEnclaveConstraint`
The KDS enclave constraint controls how your enclave will attest to the KDS enclave at the URL provided on startup (see [enclave constraints](constraints.md)).

!!!note
    For the R3 KDS, the following constraint should be used: `S:B4CDF6F4FA5B484FCA82292CE340FF305AA294F19382178BEA759E30E7DCFE2D PROD:1 SEC:STALE`.

### Choosing a value for the `masterKeyType`
The KDS contains several internal master keys which may be used when deriving keys for user enclaves.
The master key is an internal secret of the KDS instance that is used during key derivation to prevent other KDS instances from deriving the same keys.
There are several supported key types, each with different trust models:

- `development` - A stable master key which is not suitable for production workloads, but can be used to test KDS integration. Release mode enclaves cannot use this key type.
- `akv_hsm` - A production ready master key which is backed by an Azure Key Vault. The key is end-to-end encrypted, however users of this key are assuming trust in Microsoft and R3.
- `cluster` - A production ready master key which resides entirely within SGX enclaves. Neither R3 nor the KDS hosting provider have access to this key.

### Defining the `policyConstraint` section
!!!warning
    Selection of the KDS policy constraint can have significant security and operational implications.
    For this reason, users are strongly encouraged to read the following sections in their entirety.

The `policyConstraint` section defines which enclaves can access a derived key.
It is important to choose a constraint which is strict enough to prevent unauthorised access the key, but also lenient enough to allow for upgrades of enclave code and data migration if required.
Example configurations are included later in the section.

### Setting the `constraint` property
The `constraint` property of `policyConstraint` functions in a similar manner to the [`EnclaveConstraint`](api/-conclave/com.r3.conclave.common/-enclave-constraint/index.html) object which is used when attesting to a Conclave enclave.
When a request for a key is received by the KDS, the KDS attests that the key policy constraint matches the details of the requesting enclave before releasing a derived key.
Just like Conclave attestation, it follows the [enclave constraints DSL](constraints.md).

### Setting the `useOwnCodeHash` and `useOwnCodeSignerAndProductID` properties
In addition to the `constraint` property, the `policyConstraint` section has two properties which allow you to include the code hash or code signer and product ID of the current enclave to the constraint.
These parameters cannot be added to the `constraint` field directly as their values are not known at build time.

- The `useOwnCodeHash` property, when set to `true`, will restrict access to the key so that it is only released to enclaves with a code hash that matches the code hash of the current enclave.
- The `useOwnCodeSignerAndProductID` property, when set to `true`, will restrict access to the key so that it is only released to enclaves with the same code signer and product ID as the current enclave.

### Example `PolicyConstraint` configurations
#### Exact version of an enclave running on a secure platform
This is an example of a restrictive policy constraint, whereby access to the derived key is restricted to release mode enclaves with a specific code hash running on a fully patched and up-to-date SGX capable host.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:SECURE"
            useOwnCodeHash = true
        }
    }
}
```

This is a restrictive policy constraint with significant operational implications.
Because of the code hash requirement, persisted data will be inaccessible to subsequent versions of the enclave.
Finally, if the system is not fully patched, the derived key will not be accessible and the enclave may be denied access to storage keys until patches are installed.

#### Exact version of an enclave running on a platform that may need updating
This is an example of a slightly less restrictive policy constraint, whereby access to the derived key is permitted in cases where non-critical security patches are available for the host system.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:STALE"
            useOwnCodeHash = true
        }
    }
}
```

This avoids the denial of service that happens in the more restrictive case above by giving the enclave host time to patch their systems to bring them back to the `SECURE` state.
The operational implications of enclave updates are not affected however, as access to the derived key still requires that the enclave have a specific code hash.

#### Any enclave for a particular product signed using the same key
This is an example of a permissive policy constraint, whereby access to the derived key is permitted for enclaves with a matching product ID and signing key.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:STALE"
            useOwnCodeSignerAndProductID = true
        }
    }
}
```

This policy makes it easy to migrate encrypted data to a new version of the enclave, as access to the key is permitted to any enclave with a matching signing key and [product ID](enclave-configuration.md#productid).
This constraint has fewer operational implications, but security is weakened as the enclave signer must be trusted not to sign an unsafe or malicious enclave.

!!!note
    In this example, security may be enhanced by having an external auditor build and sign the enclave on the behalf of the developer.

## KDS keys for mail
The KDS is also capable of providing keys for use with [Conclave mail](mail.md).
When using KDS keys with mail, the client application requests a public key from the KDS for use in a Conclave [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) and specifies which enclaves should be permitted access to the corresponding private key.
Upon receiving mail, the enclave requests the private key and uses it to decrypt the mail object from the client.
In this manner, users can create mail objects which can be decrypted by any enclave that matches a given set of constraints, without needing to attest to the enclave first.

### Defining a KDS key spec
To make use of KDS keys with mail, the client must construct a [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) object configured for use with KDS keys.
The first step is to create a [`KDSKeySpec`](api/-conclave/com.r3.conclave.common.kds/-k-d-s-key-spec/-k-d-s-key-spec.html) object which specifies how the public key should be derived and which enclaves should be allowed access to the corresponding private key.

```java
import com.r3.conclave.common.kds.KDSKeySpec;

...
var kdsKeySpec = new KDSKeySpec(
        keyName,
        masterKeyType,
        policyConstraint);
...
```

- `keyName` - The name of the key. This name is used during key derivation and if changed, will result in a different key being generated. This can be used to separate keys by purpose.
- `masterKeyType` - The type of master key to use for the derivation (see [`MasterKeyType`](api/-conclave/com.r3.conclave.common.kds/-master-key-type/index.html)).
- `policyConstraint` - An [`EnclaveConstraint`](api/-conclave/com.r3.conclave.common/-enclave-constraint/index.html) object which describes the constraints that the enclave must meet in order to derive the corresponding private key and decrypt messages.

### KDS post office builder
Once an appropriate key spec has been created, a post office can be instantiated using the [`PostOfficeBuilder`](api/-conclave/com.r3.conclave.client/-post-office-builder/index.html) class.

```java
import com.r3.conclave.client.PostOfficeBuilder;

...
var kdsURL = new URL("<kds-url>");
var kdsEnclaveConstraint = new EnclaveConstraints("<kds-enclave-constraints>");

PostOffice postOffice = PostOfficeBuilder().usingKDS(
    kdsURL,
    kdsKeySpec,                
    kdsEnclaveConstraint    
).build();
...
```

- `<kds-url>` - The URL of the KDS instance to use. This should match the KDS instance that the enclave is configured for.
- `<kds-enclave-constraints>` - The constraints that will be used when attesting to the KDS enclave.
  These should match the expected details of the KDS.

The [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) may then be used to encrypt and decrypt messages.
