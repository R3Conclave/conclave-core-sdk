# Configuring Conclave for use with the KDS
This page covers how to configure your enclave project to use KDS keys.
More detailed information about the architecture of the KDS can be found [here](kds-detail.md).

## What is the KDS?
By default, Conclave persists encrypted data outside the enclave using keys which are specific to the CPU which the enclave is running on.
This causes problems for cloud applications where virtual machines may be re-provisioned and moved to different hardware.

In addition to CPU based keys for storage, Conclave makes use of random session keys for communication.
This presents additional problems for cloud applications which involve horizontal scaling, because the session key will be different for each enclave in the cluster.

The Conclave Key Derivation Service (KDS) is an enclave based service which solves these problems by providing Conclave enclaves a means to securely derive stable keys for both storage and communication.
R3 provides a publicly accessible instance of the KDS as part of the Conclave Cloud Platform which may be used by any Conclave based enclave.

!!!Note
    The URL for the R3 development KDS deployment is `https://kds.dev.conclave.cloud`.
    This URL may be changed in a later deployment of the KDS.

## Configuring the KDS URL
For an enclave to obtain keys from a KDS for either storage or communication, the URL of a KDS instance must be provided when the enclave is started.

!!!Note
    If the KDS URL is not provided and the enclave is a simulation or debug mode enclave, a warning will be printed and the enclave will default to internally derived keys based on the enclave code signer.
    This behavior allows for enclave development without a connection to a KDS.
    If a release mode enclave is started without the KDS URL, an error will be generated and the enclave will not start.

### Web host configuration
If you are using the [Conclave web host](conclave-web-host.md), provide the KDS URL and timeout duration in seconds on the command line when you start your application:

```
--kds.url=https://kds.dev.conclave.cloud
--kds.connection.timeout.seconds=60
```

### Custom host configuration
If you are writing a custom host for your enclave, or you're instantiating the enclave as part of an existing project, you can configure the KDS URL by providing a [`KDSConfiguration`](api/-conclave/com.r3.conclave.host.kds/-k-d-s-configuration/index.html) object when starting the enclave (see [`EnclaveHost.start`](api/-conclave/com.r3.conclave.host/-enclave-host/start.html)):

```java
import com.r3.conclave.host.kds.KDSConfiguration;

...

KDSConfiguration kdsConfiguration = new KDSConfiguration("https://kds.dev.conclave.cloud");
EnclaveHost enclaveHost = EnclaveHost.load("com.example.MyEnclave");
enclaveHost.start(null, null, null, kdsConfiguration) {}

```

## KDS keys for persistent storage
To use KDS derived keys for persistent storage, you need to specify how to derive the storage key.
Key specifications are configured on a per-enclave basis and are included in the enclave `build.gradle`.

The format of the KDS configuration is as follows:

```groovy
conclave {
    ...
    kds {
        kdsEnclaveConstraint = "<KDS enclave policy constraints>"
        persistencekeySpec {
            masterKeyType = ("development"|"cluster"|"akv_hsm")
            policyConstraint {
                constraint = "<key policy constraints>"
                useOwnCodeHash = (true|false)                 // Optional
                useOwnCodeSignerAndProductID = (true|false)   // Optional
            }
        }
    }
    ...
}
```

#### KDS block
The `kds {}` section contains all KDS related configuration:

- `kdsEnclaveConstraint` - The constraints that the KDS enclave must match. The enclave will use these constraints to attest to the KDS at the URL provided on startup.
- `persististenceKeySpec` - Subsection containing specifications for how encrypted storage keys should be derived.

#### Persistence key specification section (`persistenceKeySpec`)
- `masterKeyType` - Which KDS master key should we use when deriving a key, supported values are [`development`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-d-e-v-e-l-o-p-m-e-n-t/index.html), [`cluster`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-c-l-u-s-t-e-r/index.html) and [`azure_hsm`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-a-z-u-r-e_-h-s-m/index.html). See [KDS detail](kds-detail.md#what-is-the-master-key) regarding conclave master keys.
- `policyConstraint` - Subsection which contains configuration for the constraints that an enclave must meet to access a key generated by the KDS.

#### Policy constraint section (`policyConstraint`)
- `constraint` - The enclave should meet this policy constraint to be allowed to derive the key. This has the same format as the [enclave constraints](constraints.md) DSL, which Conclave uses for attestation.
- `useOwnCodeHash` - Use the code hash of this enclave. This will add the code hash of the enclave to the `constraint` property at runtime.
- `useOwnCodeSignerAndProductID` - Use the code signer and product ID of this enclave. This will add the code signer and product ID of the enclave to the `constraint` property at runtime.

!!!note
    For more information on the key derivation process, see [KDS detail](kds-detail.md#deriving-keys-from-the-key-specification).

### Choosing a value for the `kdsEnclaveConstraint`
The KDS enclave constraint controls how your enclave will attest to the KDS enclave at the URL provided on startup (see [enclave constraints](constraints.md)).

!!!Note
    For the R3 development KDS, the following constraint should be used: `S:B4CDF6F4FA5B484FCA82292CE340FF305AA294F19382178BEA759E30E7DCFE2D PROD:1 SEC:STALE`.

### Choosing a value for the `masterKeyType`
The KDS contains several internal master keys which may be used when deriving keys for user enclaves.
The master key is an internal secret of the KDS instance that is used during key derivation to prevent other KDS instances from deriving the same keys.
There are several supported key types, each with different trust models:

- [`development`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-d-e-v-e-l-o-p-m-e-n-t/index.html) - A stable master key which is not suitable for production workloads, but can be used to test KDS integration. Release mode enclaves cannot use this key type.
- [`azure_hsm`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-a-z-u-r-e_-h-s-m/index.html) - A production-ready master key which is backed by an Azure Key Vault. The key is end-to-end encrypted. However, users of this key are assuming trust in Microsoft and R3.
- [`cluster`](api/-conclave%20-core/com.r3.conclave.common.kds/-master-key-type/-c-l-u-s-t-e-r/index.html) - A production-ready master key which resides entirely within SGX enclaves. Neither R3 nor the KDS hosting provider have access to this key.

### Defining the `policyConstraint` section
The `policyConstraint` section defines which enclaves can access a derived key.
It is important to choose a constraint which is:

- Strict enough to prevent unauthorised access the key.
- Lenient enough to allow for upgrades of enclave code and data migration if required.

Example configurations are included later in the section.

!!!Warning
    Selection of the KDS policy constraint can have significant security and operational implications.
    For this reason, users are strongly encouraged to read the following sections in their entirety.

### Setting the `constraint` property
The `constraint` property of `policyConstraint` functions in a similar manner to the [`EnclaveConstraint`](api/-conclave/com.r3.conclave.common/-enclave-constraint/index.html) object which is used when attesting to a Conclave enclave.
When a request for a key is received by the KDS, the KDS attests that the key policy constraint matches the details of the requesting enclave before releasing a derived key.
Just like Conclave attestation, it follows the [enclave constraints DSL](constraints.md).

### Setting the `useOwnCodeHash` and `useOwnCodeSignerAndProductID` properties
The `useOwnCodeHash` and `useOwnCodeSignerAndProductID` properties of the `policyConstraint` section allow you to add the code hash or code signer and product ID of the current enclave in the `constraint` property.
These parameters cannot be added to the `constraint` field directly as their values are not known at build time.

- The `useOwnCodeHash` property, when set to `true`, will restrict access to the key so that it is only released to enclaves with a code hash that matches the code hash of the current enclave.
- The `useOwnCodeSignerAndProductID` property, when set to `true`, will restrict access to the key so that it is only released to enclaves with the same code signer and product ID as the current enclave.

### Example `PolicyConstraint` configurations
#### Exact version of an enclave running on a secure platform
In this restrictive policy constraint example, access to the derived key is restricted to release mode enclaves with a specific code hash running on a fully patched and up-to-date SGX-capable host.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:SECURE"
            useOwnCodeHash = true
        }
    }
}
```

This is a restrictive policy constraint with significant operational implications.
Because of the code hash requirement, persisted data will be inaccessible to subsequent versions of the enclave.
Also, if the system is not fully patched, the derived key will not be accessible and the enclave may be denied access to storage keys until patches are installed.

#### Exact version of an enclave running on a platform that may need updating
In this slightly less restrictive policy example, access to the derived key is permitted in cases where non-critical security patches are available for the host system.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:STALE"
            useOwnCodeHash = true
        }
    }
}
```

This constraint doesn't affect the operational implications of enclave updates because access to the derived key still requires that the enclave has a specific code hash.
However, it avoids the denial of service that happens in the more restrictive case above by giving the enclave host time to patch their systems to bring them back to the `SECURE` state.

#### Any enclave for a particular product signed using the same key
In this permissive policy constraint example, access to the derived key is permitted for enclaves with a matching [product ID](enclave-configuration.md#productid) and signing key.

```groovy
kds {
    persistenceKeySpec {
        policyConstraint {
            constraint = "SEC:STALE"
            useOwnCodeSignerAndProductID = true
        }
    }
}
```

This constraint has fewer operational implications, as the enclave code can be updated without losing access to persisted data.
However, security is weakened with this constraint, as the enclave signer must be trusted not to sign an unsafe or malicious enclave.

!!!Note
    In this example, security may be enhanced by having an external auditor build and sign the enclave on the behalf of the developer.

## KDS keys for Conclave Mail
The KDS is also capable of providing keys for use with [Conclave Mail](mail.md) through use of a specially constructed [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html).

When using a KDS post office, the post office requests a public key from the KDS for use in a Conclave [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) and specifies which enclaves should be permitted access to the corresponding private key.
Upon receiving Mail, the enclave requests the private key from the same KDS and uses it to decrypt the Mail object from the client.
In this manner, users can create Mail objects which can be decrypted by any enclave that matches a given set of constraints, without first having to receive and attest to the [`EnclaveInstanceInfo`](api/-conclave/com.r3.conclave.common/-enclave-instance-info/index.html) of a specific enclave.

### Configuring the Enclave
To make use of KDS keys for Mail, the `kdsEnclaveConstraints` field in the enclaves `build.gradle` must be configured.
This configuration alone is sufficient to use KDS keys with Mail.

```groovy
...
conclave {
    kds {
        kdsEnclaveConstraints = "<KDS enclave policy constraints>"
    } 
}
...
```

!!!Note
    For the R3 KDS, the following constraint should be used: `S:B4CDF6F4FA5B484FCA82292CE340FF305AA294F19382178BEA759E30E7DCFE2D PROD:1 SEC:STALE`.

### Defining a KDS key spec
To make use of KDS keys with Mail, the client must construct an appropriately configured [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) object with which to encrypt Mail.
The first step is to create a [`KDSKeySpec`](api/-conclave/com.r3.conclave.common.kds/-k-d-s-key-spec/-k-d-s-key-spec.html) object which specifies how the public key should be derived and which enclaves should be allowed access to the corresponding private key:

```java
import com.r3.conclave.common.kds.KDSKeySpec;

...
var kdsKeySpec = new KDSKeySpec(
        keyName,
        masterKeyType,
        policyConstraint);
...
```

- `keyName` - The name of the key. This name is used during key derivation and if changed, will result in a different key being generated. This can be used to separate keys by purpose.
- `masterKeyType` - The type of master key to use for the derivation (see [`MasterKeyType`](api/-conclave/com.r3.conclave.common.kds/-master-key-type/index.html)).
- `policyConstraint` - A string which specifies the constraints that the enclave must meet in order to derive the corresponding private key and decrypt messages. The string should be in the [enclave constraints DSL](constraints.md) format.

### Using the KDS post office builder
After creating an appropriate key spec, you can instantiate a post office using the [`PostOfficeBuilder`](api/-conclave/com.r3.conclave.client/-post-office-builder/index.html) class.

```java
import com.r3.conclave.client.PostOfficeBuilder;

...
var kdsURL = new URL("<kds-url>");
var kdsEnclaveConstraint = new EnclaveConstraints.parse("<kds-enclave-constraints>");

PostOffice postOffice = PostOfficeBuilder().usingKDS(
        kdsURL,
        kdsKeySpec,                
        kdsEnclaveConstraint    
).build();
...
```

Where:

- `<kds-url>` is the URL of the KDS instance to use. This should match the KDS instance that the enclave is configured for.
- `<kds-enclave-constraints>` are the constraints that will be used when attesting to the KDS enclave.
  These should match the expected details of the KDS.

You can then use the [`PostOffice`](api/-conclave/com.r3.conclave.mail/-post-office/index.html) to encrypt and decrypt messages as usual.
