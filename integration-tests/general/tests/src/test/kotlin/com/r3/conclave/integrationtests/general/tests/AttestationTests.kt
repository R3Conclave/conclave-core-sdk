package com.r3.conclave.integrationtests.general.tests

import com.r3.conclave.common.EnclaveInstanceInfo
import com.r3.conclave.common.SHA256Hash
import com.r3.conclave.common.internal.Cursor
import com.r3.conclave.common.internal.SgxEnclaveMetadata
import com.r3.conclave.common.internal.SgxEnclaveMetadata.enclaveCss
import com.r3.conclave.common.internal.SgxMetadataCssBody.enclaveHash
import com.r3.conclave.common.internal.SgxMetadataCssKey.modulus
import com.r3.conclave.common.internal.SgxMetadataEnclaveCss.body
import com.r3.conclave.common.internal.SgxMetadataEnclaveCss.key
import com.r3.conclave.common.internal.SgxQuote.reportBody
import com.r3.conclave.common.internal.SgxReportBody.reportData
import com.r3.conclave.common.internal.SgxSignedQuote
import com.r3.conclave.common.internal.SgxSignedQuote.quote
import com.r3.conclave.host.EnclaveHost
import com.r3.conclave.host.internal.Native
import com.r3.conclave.integrationtests.general.common.tasks.CreateAttestationQuoteAction
import com.r3.conclave.integrationtests.general.common.tasks.GetEnclaveInstanceInfo
import com.r3.conclave.integrationtests.general.commontest.AbstractEnclaveActionTest
import net.fornwall.jelf.ElfFile
import net.fornwall.jelf.ElfNoteSection
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.assertThatIllegalArgumentException
import org.junit.jupiter.api.Test
import java.nio.channels.FileChannel
import java.nio.channels.FileChannel.MapMode.READ_ONLY
import java.nio.file.Path

class AttestationTests : AbstractEnclaveActionTest() {
    @Test
    fun `enclave info`() {
        val f = getEnclaveFile()

        val metadataCursor = Cursor.allocate(SgxEnclaveMetadata.INSTANCE)
        //  This is called just to produce some C useful output in the logs
        Native.getMetadata(f.toString(), metadataCursor.buffer.array())

        val metadataBytes = FileChannel.open(f).use { channel ->
            // We use a mapped byte buffer as that's the only entry point where ElfFile doesn't read in the entire file.
            val elfFile = ElfFile.from(channel.map(READ_ONLY, 0, channel.size()))


            val metadataSection = elfFile.firstSectionByName(".note.sgxmeta") as ElfNoteSection
            check(metadataSection.name == "sgx_metadata")
            metadataSection.descriptorBytes()
        }

        val metadata = Cursor.wrap(SgxEnclaveMetadata.INSTANCE, metadataBytes)

        val metaCodeHash = SHA256Hash.get(metadata[enclaveCss][body][enclaveHash].read())
        val metaCodeSigningKeyHash = SHA256Hash.hash(metadata[enclaveCss][key][modulus].bytes)

        enclaveHost().enclaveInstanceInfo.enclaveInfo.apply {
            assertThat(codeHash).isEqualTo(metaCodeHash)
            assertThat(codeSigningKeyHash).isEqualTo(metaCodeSigningKeyHash)
        }
    }

    private fun getEnclaveFile(): Path {
        val enclaveHandleField = EnclaveHost::class.java.getDeclaredField("enclaveHandle").apply { isAccessible = true }
        val enclaveHandle = enclaveHandleField.get(enclaveHost())

        val enclaveFileField = enclaveHandle.javaClass.getDeclaredField("enclaveFile").apply { isAccessible = true }
        return enclaveFileField.get(enclaveHandle) as Path
    }

    @Test
    fun `EnclaveInstanceInfo serialisation round-trip`() {
        val roundTrip = EnclaveInstanceInfo.deserialize(enclaveHost().enclaveInstanceInfo.serialize())
        assertThat(roundTrip).isEqualTo(enclaveHost().enclaveInstanceInfo)
    }

    @Test
    fun `EnclaveInstanceInfo deserialize throws IllegalArgumentException on truncated bytes`() {
        val serialised = enclaveHost().enclaveInstanceInfo.serialize()
        for (truncatedSize in serialised.indices) {
            val truncated = serialised.copyOf(truncatedSize)
            val thrownBy = assertThatIllegalArgumentException()
                .describedAs("Truncated size $truncatedSize")
                .isThrownBy { EnclaveInstanceInfo.deserialize(truncated) }

            if (truncatedSize > 3) {
                thrownBy.withMessage("Truncated EnclaveInstanceInfo bytes")
            } else {
                thrownBy.withMessage("Not EnclaveInstanceInfo bytes")
            }
        }
    }

    @Test
    fun `EnclaveInstanceInfo matches across host and enclave`() {
        val eiiFromHost = enclaveHost().enclaveInstanceInfo
        val eiiFromEnclave = callEnclave(GetEnclaveInstanceInfo())
        assertThat(eiiFromEnclave).isEqualTo(eiiFromHost)
    }

    @Test
    fun `ensure the user data is contained inside the signed quote that was generated by createAttestationQuote`() {
        val reportDataOriginal = "Test".padEnd(64, ' ')
        val signedQuote = callEnclave(enclaveHost(), CreateAttestationQuoteAction(reportDataOriginal.toByteArray())) { it }
        val signedQuoteByteCursor = Cursor.wrap(SgxSignedQuote.INSTANCE, signedQuote)

        val reportDataFromSignedQuote = signedQuoteByteCursor[quote][reportBody][reportData].bytes
        assertThat(String(reportDataFromSignedQuote)).isEqualTo(reportDataOriginal)
    }
}
