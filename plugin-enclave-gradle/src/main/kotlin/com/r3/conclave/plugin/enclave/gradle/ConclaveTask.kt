package com.r3.conclave.plugin.enclave.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.TaskExecutionException
import org.gradle.process.ExecResult
import java.io.ByteArrayOutputStream


abstract class ConclaveTask : DefaultTask() {
    companion object {
        const val CONCLAVE_GROUP = "Conclave"
    }

    abstract fun action()

    // The intention for this class is to allow people to pass the necessary configuration when calling the commandLine function
    // workingDir: Set the working directory for the command. The defaults to the project directory
    // ignoreExitValue: If set to false, exceptions are raised if the command returns a value different from zero. Otherwise, please check the result.exitValue to check if the command was successful
    // errorOutputStream: Set the error output stream if you are interested in capturing the error messages generated by the command. If set to null, the error messages are written to standard error
    data class CommandLineConfig(
        val workingDir: String? = null,
        val ignoreExitValue: Boolean = false,
        val standardOutputStream: ByteArrayOutputStream? = null,
        val errorOutputStream: ByteArrayOutputStream? = null
    )

    @TaskAction
    fun run() {
        try {
            action()
        } catch (e: Exception) {
            throw (e as? RuntimeException) ?: TaskExecutionException(this, e)
        }
    }

    fun commandLine(vararg command: Any?, commandLineConfig: CommandLineConfig = CommandLineConfig()): ExecResult {
        return commandLine(command.asList(), commandLineConfig = commandLineConfig)
    }

    fun commandLine(command: List<Any?>, commandLineConfig: CommandLineConfig = CommandLineConfig()): ExecResult {
        // Streams that store the standard output and error generated by exec
        // The content of the stream will then be printed to the console but using
        // the project logger. This will allow the user to suppress any output using
        // Gradle log flag like --quiet
        val execOutputStream = commandLineConfig.standardOutputStream ?: ByteArrayOutputStream()
        val execErrorStream = commandLineConfig.errorOutputStream ?: ByteArrayOutputStream()

        try {
            val result = project.exec { spec ->
                if (commandLineConfig.workingDir != null) {
                    spec.workingDir(commandLineConfig.workingDir)
                }

                // Store all the standard output instead of printing to the console
                spec.standardOutput = execOutputStream

                // Store all the standard error instead of printing to the console
                spec.errorOutput = execErrorStream

                // If set to false, exceptions are raised if the command returns a value different from zero
                // If set to true, please check the result.exitValue to check if the command was successful
                spec.isIgnoreExitValue = commandLineConfig.ignoreExitValue

                spec.commandLine(command)
            }

            project.logger.info(execOutputStream.toString().trimEnd())

            // There are cases when non-error messages are written to the standard error instead of standard output
            // It is assumed that if an exception is not raised or the exit value is zero that the error stream
            // only contains non-error messages and these messages should be written to the logger.info
            // Please refer to CON-384 for more details.
            if (result.exitValue == 0) {
                project.logger.info(execErrorStream.toString().trimEnd())

                // The non-messages have been logged and should be dumped because they are not error messages
                execErrorStream.reset()
            } else if (commandLineConfig.errorOutputStream == null) {

                // Log the error because the callee did not set an error stream
                project.logger.error(execErrorStream.toString().trimEnd())
            }

            return result
        } catch (exception: Throwable) {
            // Catch the exception to log any output generated by exec and throw the exception again to ensure that
            // the behaviour of the callee is preserved in case it is processing exceptions

            project.logger.info(execOutputStream.toString().trimEnd())
            project.logger.error(execErrorStream.toString().trimEnd())

            throw exception
        }
    }

    fun commandWithOutput(vararg command: String, workingDir: String? = null): String {
        val output = ByteArrayOutputStream()
        commandLine(command.asList(), CommandLineConfig(standardOutputStream = output, workingDir = workingDir))
        return output.toString().trimEnd()
    }
}
