plugins {
    id 'java-gradle-plugin'
    id 'org.jetbrains.kotlin.jvm'
}

gradlePlugin {
    plugins {
        enclavePlugin {
            id = 'com.r3.conclave.enclave'
            implementationClass = 'com.r3.conclave.plugin.enclave.gradle.GradleEnclavePlugin'
        }
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    implementation "org.jetbrains.kotlin:kotlin-reflect"

    // We need conclave-common to get the hash implementations in order to be able to parse the enclave
    // metadata file.
    implementation project(":conclave-common")
    implementation "com.github.jengelman.gradle.plugins:shadow:5.2.0"
    implementation "io.github.classgraph:classgraph:$classgraph_version"
    implementation "org.bouncycastle:bcpkix-jdk15on:$bouncycastle_version"
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin:$jackson_version"

    testImplementation "org.assertj:assertj-core:$assertj_version"
    testImplementation "org.junit.jupiter:junit-jupiter:$junit_jupiter_version"
}

/**
 * Generates the CAP cache by running native-image on the cap-cache subproject.
 * The CAP cache is packaged in the graal jar file together with the tarball of the Graal distribution.
 * Relevant native-image options:
 * -H:±ExitAfterCAPCache    Exit image generation after C Annotation Processor Cache creation. Default: - (disabled).
 * -H:±NewCAPCache          Create a C Annotation Processor Cache. Will erase any previous cache at that same location. Default: - (disabled).
 * -H:CAPCacheDir           Directory where information generated by the CAnnotation Processor are cached.
 */
task generateCAPCache(type: Exec) {
    String capCacheDir = "${project.buildDir}/graalvm-cap-cache"
    outputs.dir(capCacheDir)

    doFirst {
        commandLine "${System.getenv("GRAAL_HOME")}/bin/native-image", '--shared',
                '-H:+ExitAfterCAPCache', '-H:+NewCAPCache', "-H:CAPCacheDir=$capCacheDir",
                "--no-fallback",
                "--language:js",
                "--language:python",
                "-H:Name=cap-cache"
    }
}

// Bundle the various tools and components needed by the plugin to build enclaves
processResources {
    // The ld executable in this case is produced by compileLinuxSgx<Debug|Release> depending on whether the flag
    // -PnativeDebug is set or not. We do not always build ld with debug symbols because if the user sets
    // -PnativeDebug, the build will depend on both the release and debug versions of linuxSgx, meaning the SDK will
    // potentially be built twice.
    String cmakeBuildType = project.hasProperty("nativeDebug") ? "Debug" : "Release"

    dependsOn(":cpp:compileLinuxSgx$cmakeBuildType")
    dependsOn(":cpp:compileFatFsEnclave$cmakeBuildType")
    dependsOn(":cpp:compileSubstrateVMLib$cmakeBuildType")
    dependsOn(":cpp:compileJvmEnclaveCommon$cmakeBuildType")
    dependsOn(":cpp:compileJvmEdl$cmakeBuildType")
    dependsOn("generateCAPCache")

    def cppProject = project(":cpp")
    String cppBuildDir = "${cppProject.buildDir}/$cmakeBuildType"
    String linuxSgxBuildDir = "$cppBuildDir/linux-sgx/src/linux-sgx"
    String sgxSdkBuildDir = "$cppBuildDir/linux-sgx/linux-sgx-ext-prefix/src/linux-sgx-ext-build/sgxsdk"

    // conclave-build Dockerfile
    into("conclave-build") {
        from("${rootProject.projectDir}/containers/conclave-build")
    }

    // C common headers
    into("include") {
        from("${cppProject.projectDir}/jvm-enclave-common/include/public") {
            include "*.h"
        }
    }

    // SGX tools
    into("sgx-tools") {
        from("$linuxSgxBuildDir/build/linux") {
            include "sgx_sign"
        }
        from("$linuxSgxBuildDir/external/toolset/ubuntu20.04/ld") {
            include "ld"
        }
    }

    // linux-sgx libs
    into("linux-sgx-libs/common") {  // All enclave modes use these libs
        from("$sgxSdkBuildDir/include") {
            include "tlibc/**/*"
            include "libcxx/**/*"
        }
        from("$sgxSdkBuildDir/lib64") {
            include "libsgx_pthread.a"
            include "libsgx_tcrypto.a"
            include "libsgx_tcxx.a"
            include "libsgx_tstdc.a"
        }
    }
    into("linux-sgx-libs/hardware") {  // Only release and debug modes use these libs
        from("$sgxSdkBuildDir/lib64") {
            include "libsgx_trts.a"
            include "libsgx_tservice.a"
        }
    }
    into("linux-sgx-libs/simulation") {  // Only simulation mode uses these libs
        from("$sgxSdkBuildDir/lib64") {
            include "libsgx_trts_sim.a"
            include "libsgx_tservice_sim.a"
        }
    }

    // substratevm libs
    into("substratevm-libs/common") {  // All enclave modes use these libs
        from("$cppBuildDir/substratevm") {
            include "libsubstratevm.a"
        }
        from("$cppBuildDir/fatfs/enclave") {
            include "libfatfs_enclave.a"
        }
        from("$cppBuildDir/jvm-edl") {
            include "libjvm_enclave_edl.a"
        }
        from("$cppBuildDir/jvm-host-enclave-common") {
            include "libjvm_host_enclave_common_enclave.a"
        }
        from ("$cppBuildDir/zlib/zlib-ext-prefix/src/zlib-ext-build") {
            include "libz.a"
        }
    }
    for (enclaveMode in ["release", "debug", "simulation"]) {
        into("substratevm-libs/$enclaveMode") {
            from("$cppBuildDir/jvm-enclave-common") {
                include "libjvm_enclave_common_${enclaveMode}.a"
                rename "libjvm_enclave_common_${enclaveMode}.a", "libjvm_enclave_common.a"
            }
        }
    }

    // GraalVM CAP cache
    into("graalvm-cap-cache") {
        from(generateCAPCache)
    }
}

jar {
    manifest {
        // This is used in the plugin to add implicit dependencies of the right version.
        attributes("Conclave-Version": rootProject.version.toString())
    }
}
